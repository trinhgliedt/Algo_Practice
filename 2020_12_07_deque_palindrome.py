class Deque:
    def __init__(self):
        self.items = []

    def is_empty(self):
        return self.items == []

    def add_front(self, item):
        self.items.append(item)

    def add_rear(self, item):
        self.items.insert(0,item)

    def remove_front(self):
        return self.items.pop()

    def remove_rear(self):
        return self.items.pop(0)
        
    def size(self):
        return len(self.items)

def pal_checker(a_string):
    char_deque = Deque()
    for ch in a_string:
        char_deque.add_rear(ch)
    still_equal = True
    while char_deque.size() > 1 and still_equal:
        first = char_deque.remove_front()
        last = char_deque.remove_rear()
        if first != last:
            still_equal = False
    return still_equal
print(pal_checker("lsdkjfskf"))
print(pal_checker("radar"))
print(pal_checker("madam"))


# • Queues can assist in the construction of timing simulations.
# • Simulations use random number generators to create a real-life situation and allow us to
# answer “what if” types of questions.
# • Deques are data structures that allow hybrid behavior like that of stacks and queues.
# • The fundamental operations for a deque are add_front, add_rear, remove_front, remove_
# rear, and is_empty.
# • Lists are collections of items where each item holds a relative position.
# • A linked list implementation maintains logical order without requiring physical storage
# requirements.
# • Modification to the head of the linked list is a special case.